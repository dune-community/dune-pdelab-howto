%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Unconstrained Conforming Finite Elements}\label{Sec:UnconstrEllipticProblems}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Unconstrained Elliptic Model Problem}

\begin{frame}
\frametitle<presentation>{Abstraction}
\textbf{Code reuse requires abstraction}
\begin{itemize}
\item Put mathematical problem in abstract form.
\item Approach is based on \textit{weighted residual formulation}.
\item Represent mathematical concepts by classes.
\end{itemize}
\textbf{Abstractions should support orthogonality}
\begin{itemize}
\item Various kinds of grids and function spaces on these grids.
\item Linear and nonlinear.
\item Sequential and parallel (overlapping/nonoverlapping).
\item Adaptivity.
\item Stationary and instationary.
\item Scalar problems and systems of PDEs.
\end{itemize}
\textbf{Abstractions enable team work}
\end{frame}


\begin{frame}
\frametitle{Problem and Weak Formulation}
Consider the following model problem:
\begin{subequations} \label{Eq:Example01}
\begin{align}
-\Delta u + a u &= f &&\text{in $\Omega\subset\mathbb{R}^d$ (open, connected)},\\
\nabla u \cdot n &= 0 &&\text{on $\partial\Omega$}.
\end{align}
\end{subequations}
\medskip
\textbf{Weak formulation}. Set $U = H^1(\Omega)$.
\begin{equation*}
u\in U \quad : \quad \underbrace{\int_\Omega \nabla u \cdot \nabla v +
a u v - f v \,dx}_{r(u,v)} = 0 \qquad \forall v\in U.
\end{equation*}
Has unique solution for $a(x)\geq a_0>0$.

We call $r(u,v)$ \textbf{residual form}.

Other boundary conditions are treated later.
\end{frame}

\begin{frame}
\frametitle{Conforming Finite Element Method}
Needs conforming triangulation $E_h^0 = \{e_o,\ldots,e_{N_h^0-1} \}$ of $\Omega$.

Define the \textbf{conforming finite element space}
\begin{equation*}
U_h^k = \left\{  u\in C^0(\overline{\Omega}) \ : \ \forall e\in E_h^0: u|_{\Omega_e} \in P_{k_e} \right\} \subset H^1(\Omega)
\end{equation*}
where
\begin{itemize}
\item $\Omega_e$: domain of element $e\in E_h^0$ (this set is open).
\item $P_k$: Polynomials of total degree $k$.
\item $k_e$: Polynomial degree on element $e$.
\end{itemize}
\textbf{Discrete problem} then reads:
\begin{equation*}
u_h \in U_h^k \quad : \quad r(u_h,v) = 0 \qquad \forall v \in U_h^k.
\end{equation*}
\textbf{Note}: This definition of $U_h^k$ does not use a basis!
\end{frame}

\begin{frame}
\frametitle{Mapped Finite Element Spaces}
Construct functions in $U_h^k$ from \textbf{local basis on reference elements}:
\begin{equation*}
U_h^k\ni u_h(x) = \sum_{e\in E_h^0} \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)}
\, \hat{\phi}_{e,l}(\mu_e^{-1}(x)) \, \chi_e(x).
\end{equation*}
\begin{center}
\begin{tabular}{ll}
$n(e)$ & number of basis functions on element $e\in E_h^0$\\
$\hat\Omega_e$ & Reference element of element $e\in E_h^0$ \\
$\mu_e : \hat\Omega_e \to \Omega_e$ & Element transformation \\
$\hat\phi_{e,l} : \hat\Omega_e \to \mathbb{R}$ & Local basis function\\
$\mathcal{I}_{U_h^k} = \{0,\ldots,N_{U_h^k}-1\}$ & Global index set \\
$g : E_h^0 \times \mathbb{N}_0 \to \mathcal{I}_{U_h^k}$ & Local to global index map \\
$\mathbf{u} \in \mathbf{U} = \mathbb{R}^{\mathcal{I}_{U_h^k}}$ & Global vector of degrees of freedom\\
$\chi_e$ & Characteristic function of element $e$
\end{tabular}
\end{center}
\textbf{Note}: On $\partial\Omega_e \cap \partial\Omega_{e'}$ the function may be two-valued!
\end{frame}

\begin{frame}
\frametitle{Global Basis; Finite Element Isomorphism}
For $j\in \mathcal{I}_{U_h^k}$ set $L(j) = \{ (e,l) \, : \, g(e,l) = j\}$ (all local degrees
of freedom associated with global degree of freedom $j$).

Setting $(\mathbf{u})_k = \delta_{j,k}$ we obtain the global basis functions:
\begin{equation*}
\Phi_{U_h^k} = \left\{ \phi_j(x) \ : \ \phi_j(x) = \sum_{(e,l)\in L(j)} \hat{\phi}_{e,l}(\mu_e^{-1}(x)) \, \chi_e(x),
\ j \in \mathcal{I}_{U_h^k} \right\}.
\end{equation*}

Finite Element Isomorphism:
\begin{align*}
\text{FE}_{\Phi_{U_h^k}} : \mathbf{U} &\to U_h^k, &
\text{FE}_{\Phi_{U_h^k}}(\mathbf{u}) &= \sum_{j\in \mathcal{I}_{U_h^k}} (\mathbf{u})_j \phi_j,
\end{align*}
maps coefficient vector to a function in $U_h^k$ and vice versa.
\end{frame}

\begin{frame}
\frametitle{Algebraic Problem}
Using the basis the discrete problem can be written equivalently as an (in general nonlinear) algebraic problem:
\begin{align*}
&&& u_h \in U_h^k \quad : \quad r(u_h,v) = 0 && \forall v \in U_h^k,\\
&\Leftrightarrow && \mathbf{u}\in\mathbf{U} \quad : \quad
r\left(\text{FE}_{\Phi_{U_h^k}}(\mathbf{u}),\phi_i\right) = 0 &&
i\in\mathcal{I}_{U_h^k}, \\
&\Leftrightarrow && \mathbf{u}\in\mathbf{U} \quad : \quad
\mathcal{R}(\mathbf{u}) = \mathbf{0}.
\end{align*}
where
\begin{align*}
\mathcal{R} &: \mathbf{U} \to \mathbf{U}, &
\left(\mathcal{R}(\mathbf{u}) \right)_i :=  r\left(\text{FE}_{\Phi_{U_h^k}}(\mathbf{u}),\phi_i\right) .
\end{align*}

\textbf{Note}: For linear PDEs $\mathcal{R}$ is affine linear: $\mathcal{R}(\mathbf{u}) = \mathbf{A} \mathbf{u} - \mathbf{b}$.\\
$\mathbf{A}$ and $\mathbf{b}$  are often called stiffness matrix and load vector.
\end{frame}

\begin{frame}
\frametitle{Residual Assembly I}
Practical computation of $(\mathcal{R}(\mathbf{u}) )_i$ uses the following ingredients:

For any $e\in E_h^0$ \textbf{transform integral to the reference element}:
\begin{equation*}
\int_{\Omega_e} g(x) \, dx = \int_{\hat\Omega_e} g(\mu_e(x)) \,|\text{det} \nabla\mu_e(\hat{x})| \, d\hat{x} .
\end{equation*}

\smallskip
\textbf{On element} $e\in E_h^0$ we have in particular for $u_h \in U_h^k$:
\begin{equation*}
u_h(\mu_e(\hat{x})) = \hat{u}_h(\hat{x}) = \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)} \,\hat{\phi}_{e,l}(\hat{x}) .
\end{equation*}
(Insert $x=\mu_e(\hat{x})$ in the formula above).

\smallskip
It follows from the \textbf{chain rule}:
{\small
\begin{equation*}
(\nabla\mu_e(\hat{x}))^{T} \nabla_{x} u_h(\mu_e(\hat{x})) = \nabla_{\hat{x}} \hat{u}_h(\hat{x})
\ \Rightarrow \
\nabla_{x} u_h(\mu_e(\hat{x})) = (\nabla\mu_e(\hat{x}))^{-T} \nabla_{\hat{x}} \hat{u}_h(\hat{x})
\end{equation*}}
where $\nabla\mu_e(\hat{x})$ is the jacobian of the function $\mu_e$.

\end{frame}

\begin{frame}
\frametitle{Residual Assembly II}
{\small
\begin{equation*}
\begin{split}
&(\mathcal{R}(\mathbf{u}) )_i  = r\left(\text{FE}(\mathbf{u}),\phi_i\right)
= \sum_{e\in E_h^0} \int_{\Omega_e} \nabla \text{FE}(\mathbf{u}) \cdot \nabla\phi_i
+ a \, \text{FE}_{\Phi_{U_h^k}}(\mathbf{u}) \phi_i - f \phi_i \,dx\\
&= \sum_{(e,m) : g(e,m)=i} \int_{\Omega_e}
\left[ \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)} \nabla_x \hat\phi_{e,l}(\mu_e^{-1}(x))\right]
\cdot \nabla_x \hat\phi_{e,m}(\mu_e^{-1}(x))\\
& + a \, \left[ \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)} \hat\phi_{e,l}(\mu_e^{-1}(x))\right] \hat\phi_{e,m}(\mu_e^{-1}(x))
- f \hat\phi_{e,m}(\mu_e^{-1}(x)) \, dx\\
&= \sum_{(e,m) : g(e,m)=i} \int_{\hat\Omega_e}
\Biggl\{\left[ \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)} (\nabla \mu_e(\hat{x}))^{-T}\nabla_{\hat{x}} \hat\phi_{e,l}(\hat{x})\right]
\cdot (\nabla \mu_e(\hat{x}))^{-T} \nabla_{\hat{x}} \hat\phi_{e,m}(\hat{x})\\
& + a \, \left[ \sum_{l=0}^{n(e)-1} (\mathbf{u})_{g(e,l)} \hat\phi_{e,l}(\hat{x}) \right] \hat\phi_{e,m}(\hat{x})
- f \hat\phi_{e,m}(\hat{x}) \Biggr\} |\text{det} \nabla\mu_e(\hat{x})| \, d\hat{x} .
\end{split}
\end{equation*}}
\end{frame}

\begin{frame}
\frametitle{Local Operator}
Define restriction to local degrees of freedom
\begin{align*}
\mathbf{U}_e &= \mathbb{R}^{n(e)}, &
\mathbf{R}_e &: \mathbf{U} \to \mathbf{U}_e, &
\left(\mathbf{R}_e(\mathbf{u})\right)_l &= (\mathbf{u})_{g(e,l)} \quad 0\leq l < n(e).
\end{align*}
Define \textit{local operator} $\bm{\alpha}^{\text{vol}}_{h,e} : \mathbf{U}_e \to \mathbf{U}_e$ (user part):
{\small\begin{equation*}
\begin{split}
&\bigl(\bm{\alpha}^{\text{vol}}_{h,e}({\color{cyan}\mathbf{u}})\bigr)_m  = \int_{\hat\Omega_e}
\Biggl\{\left[ \sum_{l=0}^{n(e)-1} ({\color{cyan}\mathbf{u}})_{l} {\color{purple}
(\nabla \mu_e(\hat{x}))^{-T}} {\color{blue}\nabla_{\hat{x}} \hat\phi_{e,l}(\hat{x})} \right]
\cdot {\color{purple}(\nabla \mu_e(\hat{x}))^{-T}} {\color{blue}\nabla_{\hat{x}} \hat\phi_{e,m}(\hat{x})}\\
& + {\color{olive} a} \, \left[ \sum_{l=0}^{n(e)-1} ({\color{cyan}\mathbf{u}})_{l}
 {\color{blue}\hat\phi_{e,l}(\hat{x})} \right] {\color{blue}\hat\phi_{e,m}(\hat{x})}
- {\color{olive} f} {\color{blue}\hat\phi_{e,m}(\hat{x})} \Biggr\} {\color{purple}\text{det} \nabla\mu_e(\hat{x})} \, d\hat{x} .
\end{split}
\end{equation*}}
Residual assembly is written generically as:
\begin{equation*}
\mathcal{R}(\mathbf{u}) = \sum_{e\in E_h^0} \mathbf{R}_e^T \bm{\alpha}^{\text{vol}}_{h,e} (\mathbf{R}_e \mathbf{u})
\end{equation*}
$\bm{\alpha}^{\text{vol}}_{h,e}$: \textbf{compute all residual contributions of one element}.
\end{frame}


\begin{frame}
\frametitle{Solving the Algebraic System}
Use damped Newton method.

Given $\mathbf{u}^0\in\mathbf{U}$. Compute $\mathbf{r}^0 = \mathcal{R}(\mathbf{u}^0)$. Set $k=0$.

Iterate until convergence:
\begin{enumerate}
\item Assemble Jacobian System $\mathbf{A}^k = \nabla\mathcal{R}(\mathbf{u}^k)$.
\item Solve $\mathbf{A}^k \mathbf{z}^k = \mathbf{r}^k$ with some linear solver.
\item Update $\mathbf{u}^{k+1} = \mathbf{u}^{k} - \sigma^k \mathbf{z}^{k}$. $\sigma\in(0,1]$.
\item Compute new residual $\mathbf{r}^{k+1} = \mathcal{R}(\mathbf{u}^{k+1})$.
\item Set $k = k +1$.
\end{enumerate}

We need methods to compute $\mathcal{R}(\mathbf{u})$ and $\nabla\mathcal{R}(\mathbf{u})$.
\end{frame}

\begin{frame}
\frametitle{Jacobian}
The Jacobian matrix is defined as
\begin{equation*}
(\mathbf{A})_{i,j} = (\nabla\mathcal{R}(\mathbf{u}))_{i,j}
= \frac{\partial (\mathcal{R})_i}{\partial (\mathbf{u})_j}(\mathbf{u})
= \sum_{(e,m,l) : g(e,m)=i \wedge g(e,l)=j} \frac{\partial (\bm{\alpha}_{h,e}^{\text{vol}})_m }{\partial (\mathbf{u})_l } (\mathbf{R}_e \mathbf{u}).
\end{equation*}

Again, the Jacobian can be computed from local contributions:
\begin{equation*}
\mathbf{A} = \sum_{e\in E_h^0} \mathbf{R}_e^T \nabla\bm{\alpha}_{h,e}^{\text{vol}}(\mathbf{R}_e \mathbf{u}) \, \mathbf{R}_e.
\end{equation*}

The local Jacobians can be
\begin{itemize}
\item programmed explicitly by the user, or
\item derived generically through numerical differentiation. This requires only coding
of the local residual contributions $\bm{\alpha}_{h,e}^{\text{vol}}$.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{The Linear Case}
is a special case of the nonlinear case \ldots
\begin{enumerate}
\item Given $\mathbf{u}^0\in\mathbf{U}$.
\item Compute $\mathbf{r} = \mathcal{R}(\mathbf{u}^0)$.
\item Assemble Jacobian System $\mathbf{A} = \nabla\mathcal{R}(\mathbf{u}^0)$.
\item Solve $\mathbf{A} \mathbf{z} = \mathbf{r}$ with some linear solver.
\item Update $\mathbf{u} = \mathbf{u}^{0} - \mathbf{z}$.
\end{enumerate}
\end{frame}

\subsection{Example 1}

\begin{frame}
\frametitle{Example 1 Overview}
The first example implements model problem \eqref{Eq:Example01}.

It consists of the following files:
\begin{itemize}
\item \lstinline{example01.cc} -- the file to be compiled.
\item \lstinline{example01_main.hh} -- main function. Instantiates a grid and runs the variants.
\item \lstinline{example01a_Qk.hh} -- solve model problem \eqref{Eq:Example01} with $Q_1$ or $Q_2$ elements.
\item \lstinline{example01a_RT.hh} -- same with nonconforming rotated bilinear (``Rannacher-Turek'' element).
\item \lstinline{example01a_operator.hh} -- local operator implementing $\bm{\alpha}_{h,e}^{\text{vol}}$.
\item \lstinline{example01b_Q2.hh} -- solve nonlinear variant of the model problem \eqref{Eq:Example01} with $Q_2$ elements.
\item \lstinline{example01b_operator.hh} -- local operator for nonlinear variant.
\end{itemize}
\end{frame}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Function \lstinline{main}}
\framesubtitle<presentation>{File \texttt{src/course-examples/example01\_main.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01_main.hh}
\end{frame}
\mode<article>{
For completeness we show the main function that just instantiates a \lstinline{YaspGrid} object
and calls the variants.

Main functions will not be shown in later examples.

\begin{Lst}[File src/course-examples/example01\_main.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01_main.hh}
\end{Lst}}


\begin{frame}
\frametitle{Driver for Solving Stationary Linear Problems}
\framesubtitle{About \lstinline{example01a_Qk.hh}}
\begin{enumerate}
\item Define useful constants/types like dimension or basic numeric type.
\item Make \textit{grid function space} which corresponds to $U_h^k$. It requires
\begin{itemize}
\item a \textit{finite element map} defining a local basis on each element.
\item a method to set up \textit{constraints} on the function space (empty here).
\item a suitable vector backend.
\end{itemize}
\item Make \textit{grid operator} computing $\mathcal{R}(\mathbf{u})$, $\nabla\mathcal{R}(\mathbf{u})$. It requires
\begin{itemize}
\item a local operator which provides $\bm{\alpha}_{h,e}^{\text{vol}}$,
\item trial and test grid function spaces, possibly with constraints,
\item a suitable matrix backend,
\item the field types for the domain and range of the operator (also
  the field type for its jacobian matrix may be set separately).
\end{itemize}
\item Select a linear solver backend (see vector/matrix backend).
\item Solve the linear problem given with the selected solver backend.
\begin{itemize}
\item \textit{Vector container} is used to store degrees of freedom $\mathbf{u}\in\mathbf{U}$.
\end{itemize}
\item Output graphics files to visualize solution with ParaView.
\begin{itemize}
\item \textit{Discrete grid function} implements finite element isomorphism.
\end{itemize}
\end{enumerate}
\end{frame}


\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Unconstrained Elliptic Problem with $Q_1$}
\framesubtitle<presentation>{File \texttt{src/course-examples/example01a\_Qk.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01a_Qk.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example01a\_Qk.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01a_Qk.hh}
\end{Lst}}


\begin{frame}
\frametitle{Local Operator}
\begin{itemize}
\item The local operator implements $\bm{\alpha}_{h,e}^{\text{vol}}$ (and more).
\item Class template \lstinline{GridOperator} builds on a local operator and
provides $\mathcal{R}(\mathbf{u})$, $\nabla\mathcal{R}(\mathbf{u})$ \textit{generically}.
\item Works for many different discretizations (see below).
\item Works as well for systems of PDEs (see below).
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Local Operator Implementation}
\framesubtitle{About \lstinline{example01a_operator.hh}}
A local operator is a class providing the following:
\begin{itemize}
\item Flags controlling the sparsity pattern assembly.
\item Method \lstinline{pattern_volume} assembling sparsity pattern (default provided).
\item Flags controlling which terms to assemble.
\item Method \lstinline{alpha_volume} computing $\bm{\alpha}_{h,e}^{\text{vol}}(\mathbf{u})$.
\item Method \lstinline{jacobian_volume} computing $\nabla\bm{\alpha}_{h,e}^{\text{vol}}(\mathbf{u})$.
This method can be provided generically through numerical differentiation.
\item Method \lstinline{jacobian_apply_volume} computing $\nabla\bm{\alpha}_{h,e}^{\text{vol}}(\mathbf{u})\mathbf{u}$.
This method can be provided generically through numerical differentiation.
\item Possibly more methods (to be introduced later):
\begin{itemize}
\item \lstinline{alpha_boundary}, \lstinline{alpha_skeleton} -- boundary/interior face integrals.
\item \lstinline{lambda_volume}, \lstinline{lambda_boundary} -- parts of the residual depending on the test function only (optional).
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{\lstinline{alpha_volume} Method}
The method \lstinline{alpha_volume} has the following signature:
\begin{lstlisting}[basicstyle=\scriptsize]
template<typename EG, typename LFSU, typename X,
         typename LFSV, typename R>
void alpha_volume (const EG& eg, const LFSU& lfsu, const X& x,
                   const LFSV& lfsv, R& r) const;
\end{lstlisting}
Where the arguments are:
\begin{itemize}
\item \lstinline{eg} -- a codim 0 entity $e\in E_h^0$.
\item \lstinline{lfsu} -- local basis $\hat\phi_{e,l}$ for trial space.
\item \lstinline{x} -- local coefficients $(\mathbf{u})_l$.
\item \lstinline{lfsv} -- local basis $\hat\psi_{e,l}$ for the test space
\item \lstinline{r} -- local contribution to residual (the result).
\end{itemize}
\end{frame}


\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Local Operator for Unconstrained Elliptic Problem}
\framesubtitle<presentation>{File \texttt{src/course-examples/example01a\_operator.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01a_operator.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example01a\_operator.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01a_operator.hh}
\end{Lst}}

\begin{frame}
\frametitle{Remark on Local Operators}
In practice one would separate parameter functions such as $a, f, j$ and the boundary condition
type from the implementation of the local operator.

\begin{center}
\begin{tikzpicture}[scale=1.0]
\draw (5,4) node {\lstinline{GridOperator}};
\draw[black,thick] (3,3.5) rectangle (7,4.5);
\draw (5,2) node {\lstinline{LocalOperator}};
\draw[black,thick] (3,1.5) rectangle (7,2.5);
\draw (5,0) node {\lstinline{Parameters}};
\draw[black,thick] (3,-0.5) rectangle (7,0.5);
\draw[->,thick] (5,3.5) -- (5,2.5);
\draw[->,thick] (5,1.5) -- (5,0.5);
\end{tikzpicture}
\end{center}
The interface between \lstinline{LocalOperator} and \lstinline{Parameters} is up to you.
\end{frame}


\begin{frame}<presentation>
\frametitle{Visualization of Example 1 Results}
Left figure shows the results for $Q_1$ elements.

But we can do easily other elements as well \ldots

\begin{center}
\includegraphics[width=0.32\textwidth]{./EPS/example01a_Q1} $\hspace{1mm}$
\includegraphics[width=0.32\textwidth]{./EPS/example01a_Q2} $\hspace{1mm}$
\includegraphics[width=0.32\textwidth]{./EPS/example01a_RT}

$Q_1$ \hspace{30mm} $Q_2$ \hspace{30mm} $RT$
\end{center}

\mode<presentation>{
More on that in the excercises!
}
\end{frame}

\mode<article>{
Figure \ref{fig:Example01aResults} shows visualizations of the results computed
with \lstinline{example01}.
\begin{figure}
\begin{center}
\includegraphics[width=0.32\textwidth]{./EPS/example01a_Q1} $\hspace{1mm}$
\includegraphics[width=0.32\textwidth]{./EPS/example01a_Q2} $\hspace{1mm}$
\includegraphics[width=0.32\textwidth]{./EPS/example01a_RT}
\end{center}
\caption{Results for example 1a computed with three different finite element spaces.
From left: $Q_1$ elements, $Q_2$ elements, rotated bilinear (Rannacher-Turek)
element on an $8 \times 8$ grid.}
\label{fig:Example01aResults}
\end{figure}
}


\begin{frame}
\frametitle{Using $Q_2$ Elements}
\ldots is quite simple, see \lstinline{example01a_Qk.hh}. Just
\begin{itemize}
\item Use a different template parameter for the order $k$ in \lstinline{QkLocalFiniteElementMap}.
\item Increase quadrature order on the local operator according to k (4 in this case).
\item Use higher level in \lstinline{SubsamplingVTKWriter} to allow visualization of higher order polynomials.
\item Use a new name for the output file.
\end{itemize}

Explore the Rannacher Turek element in \lstinline{example01a_RT.hh}
\end{frame}


\begin{frame}
\frametitle{Going Nonlinear}
\ldots is also easy. Just
\begin{itemize}
\item Make a new local operator where the coefficients $a$ and $f$ depend on the solution $u$,
see \lstinline{example01b_operator}.
\item Use this new local operator in the grid operator.
\item Use class \lstinline{Newton} to solve the nonlinear algebraic problem.
\item Use a new name for the output file :-).
\end{itemize}
\end{frame}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Unconstrained Nonlinear Elliptic Problem with $Q_2$}
\framesubtitle<presentation>{File \texttt{src/course-examples/example01b\_Q2.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01b_Q2.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example01b\_Q2.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example01b_Q2.hh}
\end{Lst}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Constrained Conforming Finite Elements and Finite Volumes}\label{Sec:ConstrainedEllipticProblems}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constrained Elliptic Model Problem}

\begin{frame}
\frametitle{Problem and Weak Formulation}
Consider now the following model problem:
\begin{subequations} \label{Eq:Example02}
\begin{align}
 -\Delta u + a u  &= f &&\text{in $\Omega\subset\mathbb{R}^d$},\\
                u &= g &&\text{on $\Gamma_D\subseteq\partial\Omega$},\\
-\nabla u \cdot n &= j &&\text{on $\Gamma_N=\partial\Omega\setminus\Gamma_D$},
\end{align}
\end{subequations}
where $a(x)\geq a_0 >0$ when $\Gamma_D=\emptyset$ or $a(x)\geq 0$ else.

\textbf{Weak formulation}. For $w\in H^1(\Omega)$, $w = g$ on
$\Gamma_D$ (``extension of $g$''), set
\begin{align*}
\tilde{U} &= H_D^1(\Omega) = \{ u \in H^1(\Omega) \,:\, u|_{\Gamma_D}=0 \} \subset H^1(\Omega), \\
w + \tilde{U} &= \{ u \in H^1(\Omega) \,:\, u = w+\tilde{u} \wedge \tilde{u}\in\tilde{U}\},
\end{align*}

Then find
\begin{equation*}
u\in w+\tilde{U} \quad : \quad \underbrace{\int_\Omega \nabla u \cdot \nabla v +
a u v - f v \,dx + \int_{\Gamma_N} j v \,ds}_{r(u,v)} = 0 \qquad \forall v\in\tilde{U}.
\end{equation*}
\end{frame}

\begin{frame}
\frametitle{What is different ?}
\begin{itemize}
\item The residual form has a new term which is a boundary integral.
\begin{itemize}
\item There will be an additional method on the local operator.
\end{itemize}
\item The spaces for solution $u$ and test function $v$ are different.
\item We call $\tilde{U}$ a \textbf{constrained space}.
\item We call $w+\tilde{U}$ an \textbf{affine space}.
\item In the linear case it suffices to solve a problem in the space $\tilde{U}$:
\begin{subequations}
\begin{align*}
 -\Delta \tilde{u} + a \tilde{u}  &= f + \Delta w - a w &&\text{in $\Omega\subset\mathbb{R}^d$},\\
                \tilde{u} &= 0 &&\text{on $\Gamma_D\subseteq\partial\Omega$},\\
-\nabla \tilde{u} \cdot n &= j+\nabla w\cdot n &&\text{on $\Gamma_N=\partial\Omega\setminus\Gamma_D$},
\end{align*}
where $w$ is an extension of $g$ to $\Omega$ and $u = w + \tilde{u}$.
\end{subequations}
\item In the nonlinear case this is not possible.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Finite Element Spaces in Constrained Case}
\begin{itemize}
\item Define appropriate finite-dimensional subspace:
\begin{equation*}
\tilde{U}_h^k = \left \{ u \in U_h^k \,:\, u|_{\Gamma_D} = 0 \right\} \subset U_h^k.
\end{equation*}
(Mesh resolves the Dirichlet boundary $\Gamma_D$).
\item Provide extension $w\in U_h^k$ with ``$w=g$'' on $\Gamma_D$ in an appropriate sense.
\item Obviously, $\text{dim}\tilde{U}_h^k < \text{dim} U_h^k$.
\item Note: Dirichlet boundary conditions could also be handled by penalty methods.
This can be done easily in PDELab but is not shown here.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Realization of Dirichlet Constraints}
\begin{itemize}
\item Assume $\Phi_{U_h^k}$ is a Lagrange basis:
\begin{equation*}
\phi_j(x_i)=\delta_{i,j} \quad\text{where $x_i$ are the Lagrange points}.
\end{equation*}
\item Construct subspace via basis representation:
\begin{itemize}
\item $\mathcal{I}_{\tilde{U}_h^k} = \left\{ j\in \mathcal{I}_{U_h^k} \,:\,
x_j \not\in \Gamma_D \right\} \subset \mathcal{I}_{U_h^k}$.
\item $\Phi_{\tilde{U}_h^k} = \left\{ \phi_j\in \Phi_{U_h^k} \,:\,
j \in \mathcal{I}_{\tilde{U}_h^k} \right\} \subset \Phi_{U_h^k}$.
\item $\tilde{U}_h^k = \text{span}\Phi_{\tilde{U}_h^k}$.
\end{itemize}
\item For the coefficient space there are two options:
\begin{enumerate}
\item $\tilde{\mathbf{U}} = \mathbb{R}^{\mathcal{I}_{\tilde{U}_h^k}} \not\subseteq \mathbf{U}$.
\item $\tilde{\mathbf{U}} = \left\{ \mathbf{u}\in\mathbf{U} \,:\, (\mathbf{u})_j = 0 \  \forall
j \in \mathcal{I}_{U_h^k} \setminus \mathcal{I}_{\tilde{U}_h^k} \right\} \subset \mathbf{U}$.
\end{enumerate}
\item We choose (2) because
\begin{itemize}
\item $w + \tilde{u}$ is just adding coefficient vectors.
\item Changing $\Gamma_D$, e.g. in time-dependent problems is easy.
\end{itemize}
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{General Constrained Spaces}
\begin{itemize}
\item Constrained spaces turn up in a number of other cases:
\begin{itemize}
\item Hanging nodes.
\item Functions with zero average, rigid body modes.
\item Varying polynomial degree in conforming finite elements ($p$-method).
\item Periodic boundary conditions.
\item Artificial essential boundary conditions or ghost degrees of freedom in parallelization.
\end{itemize}
\item PDELab has a general concept to handle all types of constraints.
\item Given $U_h$ with index set $\mathcal{I}_{U_h^k}$, construct a basis of the subspace:
\begin{itemize}
\item Partition index set: $\mathcal{I}_{U_h^k} = \tilde{\mathcal{I}} \cup \bar{\mathcal{I}}$.
\item Construct new basis from given basis:
\begin{equation*}
\tilde\phi_i = \phi_i + \sum\limits_{j\in\bar{\mathcal{I}}} \omega_{i,j} \phi_j, \qquad i\in\tilde{\mathcal{I}}.
\end{equation*}
\item $\tilde{U}_h$ is spanned by the new basis.
\item In the Dirichlet case $\omega_{i,j}=0$.
\end{itemize}
\item Constrained space defined by splitting $\tilde{\mathcal{I}} \cup \bar{\mathcal{I}}$
and coefficients $\omega_{i,j}$.
\end{itemize}
\end{frame}


\subsection{Example 2}

\begin{frame}
\frametitle{Example 2 Overview}
The first example implements model problem \eqref{Eq:Example02}.

It consists of the following files:
\begin{itemize}
\item \lstinline{example02.cc} -- the file to be compiled, main function.
\item \lstinline{example02_bctype.hh} -- a function giving the splitting $\partial\Omega = \Gamma_D \cup \Gamma_N$.
\item \lstinline{example02_bcextension.hh} -- a function for $g$ and its extension $w$.
\item \lstinline{example02_operator.hh} -- local operator including inhomogeneous Neumann boundary conditions.
\item \lstinline{example02_Q1.hh} -- driver setting up and solving the problem.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Driver for Solving Constrained Linear Problem}
\framesubtitle{About \lstinline{example02_Q1.hh}}
\begin{itemize}
\item Class \lstinline{ConformingDirichletConstraints} parametrizes the grid function space
with the possibility of having Dirichlet constraints.
\item Function \lstinline{constraints} assembles constraints (i.e. the splitting
$\mathcal{I}_{U_h^k} = \tilde{\mathcal{I}} \cup \bar{\mathcal{I}}$) from a given function.
\item Function \lstinline{interpolate} initializes a coefficient vector from a given function.
(In case you asked yourself before how to do this -- here it is).
\item At the same time this defines the extension $w$ of $g$.
\item The rest is the same as before.
\end{itemize}
\end{frame}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Constrained Elliptic Problem}
\framesubtitle<presentation>{File \texttt{src/course-examples/example02\_Q1.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_Q1.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example02\_Q1.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_Q1.hh}
\end{Lst}}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Boundary Condition Type Function}
\framesubtitle<presentation>{File \texttt{src/course-examples/example02\_bctype.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_bctype.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example02\_bctype.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_bctype.hh}
\end{Lst}}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Boundary Condition Extension Function}
\framesubtitle<presentation>{File \texttt{src/course-examples/example02\_bcextension.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_bcextension.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example02\_bcextension.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_bcextension.hh}
\end{Lst}}

\begin{frame}[fragile]
\frametitle{\lstinline{alpha_boundary} Method}
Local operator is extended by a new method \lstinline{alpha_boundary}
computing the boundary integral.

\lstinline{alpha_boundary} has the following signature:
\begin{lstlisting}[basicstyle=\scriptsize]
template<typename IG, typename LFSU, typename X,
         typename LFSV, typename R>
void alpha_boundary (const IG& ig, const LFSU& lfsu_s, const X& x_s,
                     const LFSV& lfsv_s, R& r_s) const
\end{lstlisting}
Where the arguments are:
\begin{itemize}
\item \lstinline{ig} -- intersection with domain boundary.
\item \lstinline{lfsu_s} -- local basis $\hat\phi_{e,l}$ for trial space on inside element.
\item \lstinline{x_s} -- local coefficients on inside element.
\item \lstinline{lfsv_s} -- local basis $\hat\psi_{e,l}$ for test space on inside element.
\item \lstinline{r_s} -- local contribution to residual on inside element.
\end{itemize}
\end{frame}


\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Local Operator with Neumann Boundary}
\framesubtitle<presentation>{File \texttt{src/course-examples/example02\_operator.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_operator.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example02\_operator.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example02_operator.hh}
\end{Lst}}

\begin{frame}<presentation>
\frametitle{Visualization of Constrained Problem Results}
Neumann boundary condition at $x=1$, Dirichlet elsewhere.

\begin{center}
\includegraphics[width=0.48\textwidth]{./EPS/example02_Q1} \hspace{1mm}
\includegraphics[width=0.48\textwidth]{./EPS/example04}
\end{center}

Conforming $Q_1$ from example 2 left and cell-centered finite volumes from example 4 right.
\end{frame}

\mode<article>{
Figure \ref{fig:Example01aResults} shows visualizations of the results computed
with \lstinline{example01}.
\begin{figure}
\begin{center}
\includegraphics[width=0.48\textwidth]{./EPS/example02_Q1} \hspace{1mm}
\includegraphics[width=0.48\textwidth]{./EPS/example04}
\end{center}
\caption{Result for example 2 computed with $Q_1$ elements on the right.
Same problem solved with cell-centered finite volume method in example 4.}
\label{fig:Example02Results}
\end{figure}
}

\begin{frame}
\frametitle{Summary: Implementation of Mathematical Concepts}
\begin{itemize}
\item A \textit{grid function space} represents an unconstrained finite-dimensional
function space on a grid:
\begin{itemize}
\item \lstinline{gfs} $\quad\leftrightarrow\quad$ $U_h(E_h^0)$.
\end{itemize}
\item A grid function space with a \textit{constraints container} represents a constrained
finite-dimensional function space:
\begin{itemize}
\item \lstinline{gfs} $+$ \lstinline{cc} $\quad\leftrightarrow\quad$ $\tilde{U}_h(E_h^0)$.
\end{itemize}
\item A \textit{vector container} represents a vector space of coefficients:
\begin{itemize}
\item \lstinline{U u} $\quad\leftrightarrow\quad$ $\mathbf{u}\in\mathbf{U}$.
\end{itemize}
\item A grid function space and a coefficient vector represent a function in a
finite-dimensional function space:
\begin{itemize}
\item \lstinline{gfs} $+$ \lstinline{u} $\quad\leftrightarrow\quad$ $u_h\in U_h(E_h^0)$.
\end{itemize}
\item A \textit{grid operator} realizes computations with residual forms (not shown,
used in \lstinline{StationaryLinearProblemSolver}):
\begin{itemize}
\item \lstinline{go.residual(u,r)} $\quad\leftrightarrow\quad$ $\mathbf{r} = \mathcal{R}(\mathbf{u})$.
\item \lstinline{go.jacobian(u,A)} $\quad\leftrightarrow\quad$ $\mathbf{A} = \nabla\mathcal{R}(\mathbf{u})$.
\end{itemize}
\item A \textit{matrix container} represents a linear map (not shown yet):
\begin{itemize}
\item \lstinline{Matrix A} $\quad\leftrightarrow\quad$ $\mathbf{A}\in L(\mathbf{U},\mathbf{V})$.
\end{itemize}
\end{itemize}
\end{frame}

\subsection{Cell-centered Finite Volumes}

\begin{frame}
\frametitle{Problem}
We wish to demonstrate that PDELab allows also the implementation of Finite Volume methods.

Consider again the elliptic model problem:
\begin{subequations} \label{Eq:Example04}
\begin{align}
 -\Delta u + a u  &= f &&\text{in $\Omega\subset\mathbb{R}^d$},\\
                u &= g &&\text{on $\Gamma_D\subseteq\partial\Omega$},\\
-\nabla u \cdot n &= j &&\text{on $\Gamma_N=\partial\Omega\setminus\Gamma_D$},
\end{align}
\end{subequations}
where $a>0$ when $\Gamma_D=\emptyset$.

We show how to formulate this method in the framework of residual forms.
\end{frame}

\begin{frame}
\frametitle{Discrete Weak Formulation I}
For a grid $E_h^0$ define $W_h = \{ u \in L_2(\Omega) \,:\,
u|_{\Omega_e} = \text{const} \ \forall e\in E_h^0\}$. $v\in W_h$:
{\small\begin{equation*}
\begin{split}
& \sum_{e\in E_h^0} \int_{\Omega_e} (-\Delta u + au - f) v \, dx =
\sum_{e\in E_h^0} \biggl\{ \int_{\Omega_e} (au - f) v \, dx -
\int_{\partial\Omega_e} (\nabla u\cdot n) v \, ds \biggr\}\\
&\quad = \sum_{e\in E_h^0} \biggl\{ \int_{\Omega_e} (au - f) v \, dx
- \int_{\partial\Omega_e\cap\Omega} (\nabla u\cdot n) v \, ds\\
&\hspace{30mm} - \int_{\partial\Omega_e\cap\Gamma_D} (\nabla u\cdot n) v \, ds
+ \int_{\partial\Omega_e\cap\Gamma_N} j v \, ds \biggr\}\\
&\quad = \sum_{e\in E_h^0} \int_{\Omega_e} (au - f) v \, dx
- \sum_{\gamma\in E_h^1} \int_{\Omega_\gamma} (\nabla u\cdot n_\gamma) [v] \, ds\\
&\hspace{30mm} - \sum_{\gamma\in B_h^1} \int_{\Omega_\gamma\cap\Gamma_D} (\nabla u\cdot n) v \, ds
+ \sum_{\gamma\in B_h^1} \int_{\Omega_\gamma\cap\Gamma_N} j v \, ds .
\end{split}
\end{equation*}}
$E_h^1$: interior faces, $B_h^1$: boundary faces, $n_\gamma$ pointing from $e^-_\gamma$ to $e^+_\gamma$,
$x_\gamma^-$ center of $e_\gamma^-$, $x_\gamma^+$ center of $e_\gamma^+$, $[v]|_\gamma = v(x_\gamma^-) - v(x_\gamma^+)$.
\end{frame}


\begin{frame}
\frametitle{Discrete Weak Formulation II}
Approximation with difference quotient and midpoint rule:
\begin{equation*}
\begin{split}
r_h^{\text{FV}}(u_h,v) & = \sum_{e\in E_h^0} \bigl(a(x_e)u_h(x_e) - f(x_e)\bigr) v(x_e) |\Omega_e|\\
&\qquad - \sum_{\gamma\in E_h^1} \frac{u_h(x_\gamma^+)-u_h(x_\gamma^-)}{\|x_\gamma^+ - x_\gamma^-\|}
\bigl(v(x_\gamma^-) - v(x_\gamma^+)\bigr) |\Omega_\gamma|\\
&\qquad - \sum_{\gamma\in B_h^1; \Omega_\gamma\subseteq\Gamma_D} \frac{g(x_\gamma)-u_h(x_\gamma^-)}{\|x_\gamma - x_\gamma^-\|}
v(x_\gamma^-) |\Omega_\gamma|\\
&\qquad + \sum_{\gamma\in B_h^1; \Omega_\gamma\subseteq\Gamma_N} j(x_\gamma) v(x_\gamma) |\Omega_\gamma| .
\end{split}
\end{equation*}
The discrete problem then reads
\begin{equation*}
u_h \in W_h : \quad r_h^{\text{FV}}(u_h,v) = 0 \qquad \forall v \in W_h.
\end{equation*}
The interior face term is new! CCFV has no constraints!
\end{frame}

\subsection{Example 4}

\begin{frame}
\frametitle{Example 4 Overview}
Example 4 implements the cell-centered finite volume method for the elliptic model problem.

It works only on axiparallel, cube grids.

It consists of the following files:
\begin{itemize}
\item \lstinline{example04.cc} -- the file to be compiled, main function.
\item \lstinline{example04.hh} -- driver setting up and solving the problem.
\item \lstinline{example04_operator.hh} -- local operator for cell centered finite volumes.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Driver}
New things in this driver are:
\begin{itemize}
\item Use of element-wise constant functions.
\item The new local operator shown below.
\item Use CG preconditioned with AMG as solver (just for fun).
%\item Write cell data in \lstinline{VTKWriter}.
\end{itemize}
\end{frame}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Driver for Cell-Centered Finite Volumes}
\framesubtitle<presentation>{File \texttt{src/course-examples/example04.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example04.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example04.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example04.hh}
\end{Lst}}

\begin{frame}[fragile]
\frametitle{\lstinline{alpha_skeleton} Method}
Local operator is extended by a new method \lstinline{alpha_skeleton}
called once for each interior intersection.

Optionally it can be called from each element touching the intersection.

\lstinline{alpha_boundary} has the following signature:
\begin{lstlisting}[basicstyle=\scriptsize]
template<typename IG, typename LFSU, typename X, typename LFSV,
         typename R>
void alpha_skeleton (const IG& ig,
           const LFSU& lfsu_s, const X& x_s, const LFSV& lfsv_s,
           const LFSU& lfsu_n, const X& x_n, const LFSV& lfsv_n,
           R& r_s, R& r_n) const
\end{lstlisting}
Where the arguments are:
\begin{itemize}
\item \lstinline{ig} -- interior intersection.
\item \lstinline{lfsu_s, lfsu_n} -- trial space in self (inside) and neighbor (outside).
\item \lstinline{x_s, x_n} -- local coefficients in self and neighbor.
\item \lstinline{lfsv_s, lfsv_n} -- test space in self and neighbor.
\item \lstinline{r_s, r_n} -- local contribution to residual in self and neighbor.
\end{itemize}
\end{frame}

\begin{frame}<presentation>[fragile,allowframebreaks,allowdisplaybreaks]
\frametitle<presentation>{Local Operator for Cell-Centered Finite Volumes}
\framesubtitle<presentation>{File \texttt{src/course-examples/example04\_operator.hh}}
\lstinputlisting[basicstyle=\tiny,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example04_operator.hh}
\end{frame}
\mode<article>{
\begin{Lst}[File src/course-examples/example04\_operator.hh] \mbox
\nopagebreak
\lstinputlisting[basicstyle=\scriptsize,numbers=left,
numberstyle=\tiny, numbersep=2pt]{../../src/course-examples/example04_operator.hh}
\end{Lst}}


\begin{frame}
  \frametitle{Sequential Solver Backends}
A wide range of iterative methods from \lstinline!dune-istl! have been packaged into
solver backends. Here are the sequential variants.
\begin{center}\small
\begin{tabular}{|l|l|l|}\hline
solver backend & preconditioner & solver\\\hline
\lstinline!ISTLBackend_SEQ_LOOP_Jac! & Jacobi & Loop\\\hline
\lstinline!ISTLBackend_SEQ_BCGS_Jac! & Jacobi & BiCGStab\\\hline
\lstinline!ISTLBackend_SEQ_BCGS_SSOR! & SSOR & BiCGStab\\\hline
\lstinline!ISTLBackend_SEQ_CG_SSOR! & SSOR & CG\\\hline
\lstinline!ISTLBackend_SEQ_BCGS_ILU0! & ILU0 & BiCGStab\\\hline
\lstinline!ISTLBackend_SEQ_CG_ILU0! & ILU0 & CG\\\hline
\lstinline!ISTLBackend_SEQ_BCGS_ILUn! & ILU(n) & BiCGStab\\\hline
\lstinline!ISTLBackend_SEQ_CG_ILUn! & ILU(n) & CG\\\hline
\lstinline!ISTLBackend_SEQ_MINRES_SSOR! & SSOR & MinRes\\\hline
\lstinline!ISTLBackend_SEQ_SuperLU! & - & SuperLU\\\hline
\lstinline!ISTLBackend_SEQ_ExplicitDiagonal! & Jacobi & Loop\\\hline
\lstinline!ISTLBackend_SEQ_CG_AMG_SSOR<GO>! & AMG & CG\\\hline
\lstinline!ISTLBackend_SEQ_BCGS_AMG_SSOR<GO>! & AMG & BiCGStab\\\hline
\end{tabular}
\end{center}
\lstinline!GO! is a grid operator.
\end{frame}


\subsection<article>{Other Schemes to Solve the Model Problem}

\paragraph{Vertex-centered Finite Volumes}

This method uses a discontinuous test space that is constant on
``cells''. Let us introduce some notation to define this formally.

\begin{onlyenv}<article>
\frametitle<presentation>{Vertex-centered Finite Volumes}
\begin{window}[0,r,{
\includegraphics[width=0.4\textwidth]{./EPS/SecMesh2D}},{}]
$E_h^d=\{z_0,\ldots,z_{N_h^d-1}\}$ are the vertices of the mesh
(entities of codimension $d$).

$x_z$ is the position of $z\in E_h^d$.

$C_h = \{c_0,\ldots,c_{N_h^d-1}\}$ are ``cells'' around each vertex of
the mesh.
\end{window}

$\Omega_c$ is the domain of $c\in C_h$ and $x_c=x_z$ when $c$ is the
cell around $z$.

Define the \textit{discontinuous} test function space:
\begin{align*}
V_h^0 & = \{ v\in L_2(\Omega) \,|\, \forall c\in C_h : v|_{\Omega_c} =
\text{const} \},\\
\tilde{V}_h^0 &= \{ v\in V_h \,|\, \forall z\in E_h^d, x_z\in\Gamma_D : v(x_z)=0\}.
\end{align*}

\end{onlyenv}

\begin{frame}<article>
\frametitle<presentation>{Vertex Centered Finite Volumes (Contd.)}
The discontinuities are located on the \textit{skeleton} which is given by:
\begin{equation*}
\Gamma_h^{\text{int}} = \{\gamma_{e,c,c^\prime} \,|\,
\gamma_{e,c,c^\prime} = \Omega_e \cap \partial\Omega_c \cap
\partial\Omega_{c^\prime} \}
\end{equation*}
and the boundary faces are given by
\begin{equation*}
\Gamma_h^{\text{ext}} = \{\gamma_{e,c} \,|\,
\gamma_{e,c} = \partial\Omega_e \cap \partial\Omega_c \cap
\partial\Omega \}.
\end{equation*}

For $\gamma\in\Gamma_h^{\text{int}}$, $\nu_\gamma(x)$ is
the \textit{unique} unit
normal vector to $\gamma$ in point $x$.

Similarly, for
$\gamma\in\Gamma_h^{\text{ext}}$, $\nu_\gamma(x)$ is the unit outer
normal vector.

The jump of a function $v\in V_h$ in
$x\in\gamma\in\Gamma_h^{\text{int}}$ given by
\begin{equation*}
[v]_\gamma(x) = \lim_{\varepsilon\to 0-} v(x+\varepsilon \nu_\gamma(x))
-  \lim_{\varepsilon\to 0+} v(x+\varepsilon \nu_\gamma(x))\quad.
\end{equation*}
\end{frame}

\begin{frame}<article>
\frametitle<presentation>{Vertex Centered Finite Volumes (Contd.)}
The discrete problem then reads as follows. Find $u_h\in w_h+\tilde{U}_h^1$ s.t.
\begin{equation}
\underbrace{- \sum_{\gamma\in\Gamma_h^{\text{int}}} \int_\gamma
\nabla u_h \cdot \nu_\gamma \,[v]\diffd s
+ \sum_{\substack{\gamma\in\Gamma_h^{\text{ext}},\\ \gamma\subseteq\Gamma_N}}
\int_\gamma j v \diffd s\quad
- \int_\Omega fv \diffd x}_{= r_h^\text{FE}(u_h,v)} = 0,
\quad \forall v\in \tilde{V}_h^0.
\end{equation}
$\tilde{U}_h^1$ is the linear conforming finite element space and $w_h$ is
defined as before.

Typically, the integrals are evaluated with low order quadrature rules
such as the midpoint rule.

This gives a simple example with non-conforming residual form and
different trial and test functions.
\end{frame}


\paragraph{Discontinuous Galerkin}

\begin{frame}<article>
\frametitle<presentation>{Discontinuous Galerkin Finite Element
Method}
Let $k : E^0_h \to \mathbb{N}_0$ be a function that associates an
nonnegative integer with each element.

Define the discrete function space
\begin{equation*}
W_h^k = \{u\in L_2(\Omega) \,|\, \forall e\in E^0_h : u|_{\Omega_e} \in P_{k(e)}\}.
\end{equation*}

For any $x\in\Omega_f, f\in E_h^1$, define the jump of a function
$u\in W_h^k$:
\begin{equation*}
\label{Eq:Jump}
[u]_f(x) = \lim\limits_{\epsilon\to 0-} u(x+\epsilon\nu_f) -
\lim\limits_{\epsilon\to 0+} u(x+\epsilon\nu_f).
\end{equation*}

For any $x\in\Omega_f, f\in E_h^1$, define the average of a function
$u\in W_h^k$:
\begin{equation*}
\label{Eq:Average}
\langle u\rangle_f(x) = \frac{1}{2}\left(\lim\limits_{\epsilon\to 0-} u(x+\epsilon
\nu_f) +  \lim\limits_{\epsilon\to 0+} u(x+\epsilon
\nu_f)\right ).
\end{equation*}

\end{frame}


\begin{frame}<article>
\frametitle<presentation>{Discontinuous Galerkin Finite Element
Method (Contd.)}
The discrete problem for the OBB method \cite{OBB98} then reads
\begin{equation*}
u_h \in W^k_h \quad : \quad r_h^\text{OBB}(u_h,v) = 0 \qquad \forall v\in W_h^k,
\end{equation*}
where
\begin{equation*}
\begin{split}
r_h^\text{OBB}(u &,v) = \sum_{e\in E_h^0} \int_{\Omega_e} \nabla u\cdot \nabla v
 - fv \, dx \\
&+ \sum_{f\in E^1_h} \int_{\Omega_f} \langle \nabla v\cdot\nu_f\rangle [u]_f
- [v]_f \langle \nabla u\cdot \nu_f\rangle \, ds\\
&+ \sum_{\substack{b\in B^1_h\\\Omega_b\subseteq\Gamma_D}} \int_{\Omega_b} (\nabla v\cdot\nu_f) (u-g)
- v (\nabla u\cdot \nu_f) \, ds + \sum_{\substack{b\in
B^1_h\\\Omega_b\subseteq\Gamma_N}} \int_{\Omega_b} j v \,ds .
\end{split}
\end{equation*}
Note the seperation into volume, skeleton and boundary terms.
\end{frame}


\paragraph{Crouzeix-Raviart}

\begin{frame}<article>
\frametitle<presentation>{Crouzeix-Raviart Element}
Here we use the following discrete spaces:
\begin{align*}
X_h &= \{u\in L_2(\Omega) \,|\, u|_{\Omega_e}\in P_1 \text{ and $u$
continuous at face centers}\},\\
\tilde{X}_h &= \{u\in X_h \,|\, \text{``$u=0$'' on $\Gamma_D$}\}.
\end{align*}

The discrete problem then reads
\begin{equation*}
u_h \in w_h+\tilde{X}_h \quad : \quad r_h^\text{CR}(u_h,v) = 0 \qquad \forall v\in \tilde{X}_h,
\end{equation*}
where
\begin{equation*}
\begin{split}
r_h^\text{CR}(u &,v) = \sum_{e\in E_h^0} \int_{\Omega_e} \nabla u\cdot \nabla v \, dx
+ \sum_{\substack{b\in
B^1_h\\\Omega_b\subseteq\Gamma_N}} \int_{\Omega_b} j v \,ds  - \sum_{e\in E_h^0} \int_{\Omega_e} fv \, dx .
\end{split}
\end{equation*}
Again $w_h\in X_h$ such that ``$w_h=g$'' on $\Gamma_D$.
\end{frame}


\subsection<article>{Properties of the Residual Form}

\begin{frame}<article>
\frametitle<presentation>{Weighted Residual Formulation}
\begin{Def}[Weighted Residual Formulation]
We claim that all problems we ever want to solve can be written in the form
\begin{equation}
\text{Find } u_h\in w_h + \tilde{U}_h : \qquad r_h(u_h,v) =
0 \qquad \forall v\in \tilde{V}_h.
\end{equation}
Where:
\begin{itemize}
\item $\tilde{U}_h\subseteq U_h$, $\tilde{V}_h\subseteq V_h$ are
finite-dimensional function spaces and corresponding subspaces.
\item Affine shift: $u_h\in w_h + \tilde{U}_h$ for a given $w_h\in U_h$ means
$u_h = w_h + \tilde{u}_h$ for some $\tilde{u}_h\in\tilde{U}_h$.
\item $r_h : U_h \times V_h \to \mathbb{K}$ is the \textit{residual form}.
\begin{itemize}
\item $r_h$ may be \textit{nonlinear} in its first argument.
\item $r_h$ \textit{is always linear} in its second argument.
\item $r_h$ may depend on the grid in non-conforming methods.
\end{itemize}
\item We assume that this problem has a unique solution. \hfill$\square$
\end{itemize}
\end{Def}
\end{frame}

The examples above imply the following properties of $r_h$.

\begin{frame}<article>
\frametitle<presentation>{Properties of the Residual Form}
\begin{Pro}[Splitting]
$r_h$ can be split into element, skeleton and boundary sums
\begin{equation*}
r_h(u,v) = \sum_{e\in E^0_h} r^\text{vol}_{h,e}(u,v) + \sum_{f\in E^1_h} r^\text{skel}_{h,f}(u,v)
+ \sum_{b\in B^1_h} r^\text{bnd}_{h,b}(u,v)
\end{equation*}
$r_h$ can be split into a part depending
on $u$ and a part independent of $u$:
\begin{equation*}
r_h(u,v) = \alpha_h(u,v) + \lambda_h(v) .
\end{equation*}

Together we obtain
\begin{equation}
\begin{split}
r_h(u,v) &= \sum_{e\in E^0_h} \alpha^\text{vol}_{h,e}(u,v) + \sum_{f\in E^1_h} \alpha^\text{skel}_{h,f}(u,v)
+ \sum_{b\in B^1_h} \alpha^\text{bnd}_{h,b}(u,v)\\
&\quad + \sum_{e\in E^0_h} \lambda^\text{vol}_{h,e}(v) + \sum_{f\in E^1_h} \lambda^\text{skel}_{h,f}(v)
+ \sum_{b\in B^1_h} \lambda^\text{bnd}_{h,b}(v) .
\end{split}
\end{equation}
\hfill$\square$
\end{Pro}
\end{frame}

\begin{frame}<article>
\frametitle<presentation>{Properties of the Residual Form (Contd.)}
\begin{Pro}[Linearity]\label{Ass:Linearity}
$r_h$, as well as, $r^\text{vol}_{h,e}$, $r^\text{skel}_{h,f}$ and
$r^\text{bnd}_{h,b}$ are linear in their second
argument.

As a consequence we have $r_h(u,0)=0$.\hfill$\square$
\end{Pro}
\begin{Pro}[Localization]
We assume that the following holds:
\begin{subequations}
\begin{align*}
e&\in E^0_h : & r^\text{vol}_{h,e}(u,v) &= r^\text{vol}_{h,e}(\chi_{\Omega_e} u,\chi_{\Omega_e} v),\\
f&\in E^1_h : & r^\text{skel}_{h,f}(u,v) &=
r^\text{skel}_{h,f}(\chi_{\Omega_{l(f)}\cup\Omega_{r(f)}}
u,\chi_{\Omega_{l(f)}\cup\Omega_{r(f)}} v),\\
b&\in B^1_h : & r^\text{bnd}_{h,b}(u,v) &= r^\text{bnd}_{h,b}(\chi_{\Omega_{l(b)}} u,\chi_{\Omega_{l(b)}} v).
\end{align*}
\end{subequations}
where $\chi_\omega(x) : \omega \to \{0,1\}$ is the characteristic function of $\omega$.

This is a consequence of  $r^\text{vol}_{h,e}$, $r^\text{skel}_{h,e}$
and $r^\text{bnd}_{h,e}$ being integrals over an element, a face or a
boundary face.
\end{Pro}
\end{frame}

\cleardoublepage
